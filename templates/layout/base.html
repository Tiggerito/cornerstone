<!DOCTYPE html>
<html class="no-js" lang="{{ locale_name }}">
    <head>
        {{!-- 
            crossorigin="anonymous"
            This allows us to see cross origin script exceptions
            Only use it in link/script if they require it and the following header is present in the response:
            access-control-allow-origin: *
            Note the JS attribute is called crossOrigin
        --}}

        {{!-- 
            section.io
            section.io provide a CDN that caches partial pages. Any html in the cache are is returned to the browser very quicky (i.e. sub 100ms)
            And therefore any resources requested in that cache can be requested very early on in the life of loading a page.

            I've grouped the code into sections to help get the most out of this caching.

            Globaly Static Resources - always the same site wide
            Page Static Resources - always the same for a page
            Page Variable Resources - likely to change, like title, meta description, user specific data

            The first two sections are inside the page cache. They have to contain static content as they may be cached for a long time.
            Edits to code in those sections would require a full flush of the cache. e.g. edits here, edits to partial head sections, updates of the theme (changes URL identifiers)     
        --}}

        {{!-- ****** Globaly Static Resources ****** --}}
        {{!-- 
            Possible to cache at a site wide level. Rarely change and are the same on every page and could request resources.    
        --}}

        {{!-- 
            Native lazy-loading with Lazysizes as a fallback
            Loads Lazysizes only if required
            Works bast with my modified responsive-img.html file
            Must be placed early inside the head section so that its execution is not blocked
            Should Remove the 'Load Lazysizes' code already in this file as it is done here
            Can remove the theme-bundle.head_async.js script if it only contained lazysizes which is now dynamically loaded if required
            Render blocking CSS files still delay building the DOM. So on page lazy-loading images only start loading once the render blocking CSS has loaded. In this case, render blocking CSS is inline so no delay

            An improvement would be to add lazysizes.min.js into the theme to avoid a possible connection delay
        --}}
        <script>
            !function(w,d){           
                var native = 'loading' in HTMLImageElement.prototype;

                var canGoNative = function(n) {
                    if (!native) return false;
                    if (n.tagName !== 'IMG') return false;
                    if (n.sizes) return true;
                    if (!n.dataset.srcset) return true;
                    return !n.dataset.srcset.includes(',');
                }

                var loadLazySizes = function () {
                    if(!w.lazySizesConfig) {
                        w.lazySizesConfig = w.lazySizesConfig || {};
                        w.lazySizesConfig.loadMode = 1;
                        var s = d.createElement('script');
                        s.crossOrigin="anonymous";
                        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js';
                        d.getElementsByTagName('head')[0].appendChild(s);
                    }
                }

                var goNative = function (n) {
                    {{!-- These are for backwards compatibility with the old responsive-img.html --}}
                    if (!n.loading) n.loading = "lazy";
                    {{#if theme_settings.lazyload_mode '===' 'lazyload+lqip' }}
                    if (!n.classList.contains('responsive-img')) {
                        if (n.srcset) { n.style.cssText += "background-image: url('" + n.srcset + "');" };
                    }
                    {{/if}}
                    {{!-- END: These are for backwards compatibility --}}
                    if (n.dataset.src) n.src = n.dataset.src;
                    if (n.dataset.srcset) n.srcset = n.dataset.srcset;
                    if (n.dataset.sizes && n.dataset.sizes !== 'auto') n.sizes = n.dataset.sizes;
                    n.classList.remove('lazyload');
                    n.classList.add('lazyloading');
                    n.onload = function () { n.classList.add('lazyloaded'); n.classList.remove('lazyloading') };
                }

                var processNode = function (n) {
                    if (n.classList.contains('lazyload')) {
                        if (canGoNative(n)) {
                            goNative(n);
                        } else {
                            loadLazySizes();
                            if (!native) o.disconnect();
                        }
                    }
                    else if (n.tagName === 'IMG' && !n.classList.contains('normalloading')) {
                        n.classList.add('normalloading')
                        n.onload = function () { n.classList.add('normalloaded'); n.classList.remove('normalloading') };
                    }
                }

                var o = new MutationObserver(function (l) {
                    l.forEach(function (m) {
                        m.addedNodes.forEach(function (n) {
                            if (n.nodeType === 1) {
                                processNode(n);
                                n.querySelectorAll('.lazyload,img').forEach(function (e) { processNode(e) });
                            }
                        })
                    })
                });
                o.observe(d.documentElement, { subtree: true, childList: true });
            }(window,document)
        </script>

        {{!-- 
            CSS based LQIP support
            My modified responsive-img.html supports LQIP by using CSS background-image
            This CSS is needed to make the LQIP image match the positioning of the real image 
        --}}
        <style>          
            img.placeholder-lqip {
                background-repeat: no-repeat;
                background-size: contain;
                background-position: center;
            }
            img.placeholder-lqip.normalloaded, img.placeholder-lqip.lazyloaded {
                background-image: none !important;
            }
        </style>



        {{!--  the resourceHints are of no value --}}
        {{!--  {{{ resourceHints }}} --}}

        <link href="{{ head.favicon }}" rel="shortcut icon">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <script>
            {{!-- Change document class from no-js to js so we can detect this in css --}}
            document.documentElement.className = document.documentElement.className.replace('no-js', 'js');
        </script>

        {{> components/common/polyfill-script }}

        {{!-- preload theme-bundle.main.js early as it is big and it is in the footer (required) and out of the cache --}}
        <link rel="preload" href="{{cdn 'assets/dist/theme-bundle.main.js'}}" crossorigin="anonymous" as="script" fetchpriority="high">

        {{!-- 
            Main CSS - start loading early as it is big and render blocking
    
            The recommended solution is to inline everything that does the main layout for a page and async load the rest.

            Categories pages are inlined at the moment. Work is needed to inline other page types.

            This is currently messing up the faceted navigation layout and the footer layout. So need a better solution!

            I used a tool (https://www.corewebvitals.io/tools/critical-css-generator) to work out essential CSS for the category page and inlined it. 

            The inlined css is added via pages/category.html using the head partial so that it is in the pages cache area.
            The main CSS for category pages is async loaded so it does not render block.
            When generating the inline code make sure to remove the fonts at the start as they are in the head section already.

            When the main CSS has loaded it removes the inline CSS via its id of inline-css. I found having both caused layout issues.

            I'm sure there is a better way to split the CSS into essential and non essential? 

            If we knew a user has probably a cache of the main CSS file we could skip including the inlined CSS and save a bit of data.
            
            main.js plays with a few things including the faceted navigation, and this causes a small layout shift.

        --}}
        {{#if page_type '===' 'category'}}
        {{{stylesheet '/assets/css/theme.css' rel="preload" as="style" fetchpriority="high" onload="this.onload=null;this.rel='stylesheet';var e=document.getElementById('inline-css');e.parentNode.removeChild(e);"}}}
        {{else}}
        {{{stylesheet '/assets/css/theme.css' fetchpriority="high"}}}
        {{/if}}

        {{!-- Different ways to load web fonts. do after js and css as they are smaller --}}
        {{!-- {{> components/common/fonts-webfontloader-inlined-css }} --}}
        {{> components/common/fonts-local-preload-inlined-css }}

        {{!-- 
            Header logo sizing. 
            Sizing the logo image reduces the chance of a layout shift and an issue being reported in Page Speed Insights/Lighthouse.
            I've added width and height to the logo if not set to use the original unknown size
            If your logo is not showing correctly then set its exact dimensions in Page Builder->Settings->Header & Footer
        --}}
        {{!-- Header logo preload --}}
        {{#if settings.store_logo.image}}
        {{#if theme_settings.logo_size '===' 'original'}}
        <link rel="preload" href="{{getImage settings.store_logo.image 'logo_size'}}" as="image" fetchpriority="high">
        {{else}}
        <link rel="preload" href="{{getImage settings.store_logo.image 'logo_size'}}" imagesrcset="{{getImageSrcset1x2x settings.store_logo.image theme_settings.logo_size}}" as="image" fetchpriority="high">
        {{/if}}
        {{/if}}
 
        {{!-- The sudden appearance of the scrollbar seemed to cause a layout shift, so I made it show from the start --}}
        <style>
            body {
                overflow: scroll; 
            }
        </style>

        {{!-- 
            Preload specific urls in the footer scripts.
            This is a hack. it would be better for the system to provide the preload stuff for us, and/or to implement fetchpriority 
        --}}
        {{#eachIndex (split footer.scripts '"')}}
        {{#startsWith "https://cdn11.bigcommerce.com/shared/js/csrf-protection-header-" item}}
        <link rel="preload" href="{{item}}" as="script">
        {{/startsWith}}
        {{#startsWith "https://cdn11.bigcommerce.com/shared/js/datatags-" item}}
        <link rel="preload" href="{{item}}" as="script">
        {{/startsWith}}
        {{/eachIndex}}

        {{!--        
            If you use Google Optimize a preload will help reduce flicker when it changes the page  
        --}}
        {{!--
        <link rel="preload" href="https://www.googleoptimize.com/optimize.js?id=OPT-XXXXXXX" crossorigin="anonymous" as="script" fetchpriority="high">
        --}}

        {{!-- 
            You can add other preloads for scripts that are important for display but are not initially requested. e.g. widgets

            Add crossorigin if it is used in the real script tag.
        --}}

        {{!-- Pre-connecting
            Place late in head script so are the last requests to be considered. 
            Only add what is used and is requested later on 
            These are browser hits. The browser will only apply them when it has time
            https://web.dev/preconnect-and-dns-prefetch/

            Tag Rocket preconnects to all the relevant domains
        --}}

        {{!-- 
            If we have certain BigCommerce widgets (Hero Banner, Carousel, Product, Product Set) they use external scripts. 
            Note that the code for these widgets runs really late as it is dynamically loading the scripts from within the body of the page.   
            Which means the content of the widgets takes some time to show.
            A preload on pages you know use one of these widgets would be better, but the URLs may unfortunately change on you!
            Having the widget some how add its own preload would work better.
        --}}
        {{!--
        <link rel="preconnect" href="https://microapps.bigcommerce.com">
        <link rel="dns-prefetch" href="https://microapps.bigcommerce.com">
        --}}

        {{!-- BigCommerce Recaptcha --}}
        {{!--       
        <link rel="preconnect" href="https://www.google.com">
        <link rel="dns-prefetch" href="https://www.google.com"> 

        <link rel="preconnect" href="https://www.gstatic.com">
        <link rel="dns-prefetch" href="https://www.gstatic.com">
        --}}

        {{!-- Shogun --}}
        {{!--            
        <link rel="preconnect" href="https://analytics.getshogun.com">
        <link rel="dns-prefetch" href="https://analytics.getshogun.com">
        --}}

        {{!-- Just Uno --}}
        {{!--        
        <link rel="preconnect" href="https://cdn.jst.ai">
        <link rel="dns-prefetch" href="https://cdn.jst.ai">
        
        <link rel="preconnect" href="https://my.jst.ai">
        <link rel="dns-prefetch" href="https://my.jst.ai">
        
        <link rel="preconnect" href="https://aly.jst.ai">
        <link rel="dns-prefetch" href="https://aly.jst.ai">
        --}}

        {{!-- ****** Page Static Resources ****** --}}
        {{!-- Possible to cache at a page level. Rarely change but are page specific and could request resources --}}

        {{{ head.config }}}

        {{!-- This here assumes no users of this block add dynamic content --}}
        {{!-- checkout.html and order-confirmation.html do, in fact they also pulls in head.scripts --}}
        {{#block "head"}} {{/block}}

        {{!-- 
            This tells section.io where to cache up to.
            We want to make sure section.io do not cache on page types that don't have this line. Their standard blacklist is:
            checkout,cart.php,login.php,account.php,api,internalapi,remote,pageBuilder,login-as-customer,^/customer/,graphql,(\?|&).*
            What about:
            amp pages, product-options.html (amp iframe), 
            these use layout/empty instead of this: invoice.html, checkout.html, order-confirmation.html, maintenance.html
            If we could use </title> as the hole punch then all layouts would be fine.
        --}}

        {{!-- ****** Page Variable Resources ****** --}}
        {{!-- Frequently change so should not be cached. Or are tags that would not trigger any network requests. --}}
        {{!-- If you are using section.io set its hole punch to "<title" so caching stops here --}}

        <title>{{ head.title }}</title>
        {{{ head.meta_tags }}}

        <script>window.consentManagerTranslations = `{{{langJson 'consent_manager'}}}`;</script>

        <!-- head scripts start -->
        {{!-- This includes BCs GA and Facebook code, site verification code, a CSRF token (that can't be cached) and the head custom scripts --}}
        {{!-- BCs GA uses some CPU so may be better delayed a bit so it does not delay LCP --}}
        {{{head.scripts}}}
        <!-- head scripts end -->

        {{~inject 'zoomSize' theme_settings.zoom_size}}
        {{~inject 'productSize' theme_settings.product_size}}
        {{~inject 'genericError' (lang 'common.generic_error')}}
        {{~inject 'maintenanceModeSettings' settings.maintenance}}
        {{~inject 'adminBarLanguage' (langJson 'admin')}}
        {{~inject 'urls' urls}}
        {{~inject 'secureBaseUrl' settings.secure_base_url}}
        {{~inject 'cartId' cart_id}}
        {{~inject 'channelId' settings.channel_id}}
        {{~inject 'template' template}}
        {{~inject 'validationDictionaryJSON' (langJson 'validation_messages')}}
        {{~inject 'validationFallbackDictionaryJSON' (langJson 'validation_fallback_messages')}}
        {{~inject 'validationDefaultDictionaryJSON' (langJson 'validation_default_messages')}}
        {{~inject 'carouselArrowAndDotAriaLabel' (lang 'carousel.arrow_and_dot_aria_label')}}
        {{~inject 'carouselActiveDotAriaLabel' (lang 'carousel.active_dot_aria_label')}}
        {{~inject 'carouselContentAnnounceMessage' (lang 'carousel.content_announce_message')}}
    </head>
    <body>
        <svg data-src="{{cdn 'img/icon-sprite.svg'}}" class="icons-svg-sprite"></svg>

        {{> components/common/header }}
        {{> components/common/body }}
        {{> components/common/footer }}

        <script>window.__webpack_public_path__ = "{{cdn 'assets/dist/'}}";</script>

        {{!-- 
            Stop theme-bundle.main.js from blocking
            Replace the theme-bundle.main.js script and stencilBootstrap script after it with this
            Needs to be after all uses of ~inject so jsContext is populated
            This supports async and still works on IE

            I tried a way to move it into the cached head, but unfortunately it depends on head being complete and probably body being mostly done.
            It would be nice to get some of it in the cached head so it can preload the chunks (that code also requires head).
        --}}
        <script>
            !function(w,d){
                var done = false;
                var script = d.createElement('script');
                script.src = "{{cdn 'assets/dist/theme-bundle.main.js'}}";
                script.crossOrigin = "anonymous";
                script.fetchpriority = "high";
                script.async = true;
                script.onload = script.onreadystatechange = function () {
                    if (!done) {
                        var readyState = script.readyState;
                        if (!readyState || readyState == 'loaded' || readyState == 'complete') {
                            done = true;
                            {{!-- Exported in app.js --}}
                            w.stencilBootstrap("{{page_type}}", {{ jsContext }}).load();
                        }
                    }
                }
                d.head.appendChild(script);
            }(window,document)
        </script>

        {{{footer.scripts}}}
    </body>
</html>
