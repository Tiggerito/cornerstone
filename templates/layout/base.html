<!DOCTYPE html>
<html class="no-js" lang="{{ locale_name }}">
    <head>
        {{!-- 
            crossorigin="anonymous"
            This allows us to see cross origin script exceptions
            Only use it in link/script if they require it and the following header is present in the response:
            access-control-allow-origin: *
            Note the JS attribute is called crossOrigin
        --}}

        {{!-- 
            section.io
            section.io provide a CDN that caches partial pages. Any html in the cache are is returned to the browser very quicky (i.e. sub 100ms)
            And therefore any resources requested in that cache can be requested very early on in the life of loading a page.

            I've grouped the code into sections to help get the most out of this caching.

            Globaly Static Resources - always the same site wide
            Page Static Resources - always the same for a page
            Page Variable Resources - likely to change, like title, meta description, user specific data

            The first two sections are inside the page cache. They have to contain static content as they may be cached for a long time.
            Edits to code in those sections would require a full flush of the cache. e.g. edits here, edits to partial head sections, updates of the theme (changes URL identifiers)     
        --}}

        {{!-- ****** Globaly Static Resources ****** --}}
        {{!-- 
            Possible to cache at a site wide level. Rarely change and are the same on every page and could request resources.    
        --}}

        {{!-- 
            Native lazy-loading with Lazysizes as a fallback
            Loads Lazysizes only if required
            Works bast with my modified responsive-img.html file
            Must be placed early inside the head section so that its execution is not blocked
            Should Remove the 'Load Lazysizes' code already in this file as it is done here
            Can remove the theme-bundle.head_async.js script if it only contained lazysizes which is now dynamically loaded if required
            Render blocking CSS files still delay building the DOM. So on page lazy-loading images only start loading once the render blocking CSS has loaded. In this case, render blocking CSS is inline so no delay

            An improvement would be to add lazysizes.min.js into the theme to avoid a possible connection delay
        --}}
        <script>
            console.log('now start: ' + performance.now());

            !function(w,d){           
                var native = 'loading' in HTMLImageElement.prototype;

                var canGoNative = function(n) {
                    if (!native) return false;
                    if (n.tagName !== 'IMG') return false;
                    if (n.sizes) return true;
                    if (!n.dataset.srcset) return true;
                    return !n.dataset.srcset.includes(',');
                }

                var loadLazySizes = function () {
                    if(!w.lazySizesConfig) {
                        w.lazySizesConfig = w.lazySizesConfig || {};
                        w.lazySizesConfig.loadMode = 1;
                        var s = d.createElement('script');
                        s.crossOrigin="anonymous";
                        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js';
                        d.getElementsByTagName('head')[0].appendChild(s);
                    }
                }

                var goNative = function (n) {
                    {{!-- These are for backwards compatibility with the old responsive-img.html --}}
                    if (!n.loading) n.loading = "lazy";
                    {{#if theme_settings.lazyload_mode '===' 'lazyload+lqip' }}
                    if (!n.classList.contains('responsive-img')) {
                        if (n.srcset) { n.style.cssText += "background-image: url('" + n.srcset + "');" };
                    }
                    {{/if}}
                    {{!-- END: These are for backwards compatibility --}}
                    if (n.dataset.src) n.src = n.dataset.src;
                    if (n.dataset.srcset) n.srcset = n.dataset.srcset;
                    if (n.dataset.sizes && n.dataset.sizes !== 'auto') n.sizes = n.dataset.sizes;
                    n.classList.remove('lazyload');
                    n.classList.add('lazyloading');
                    n.onload = function () { n.classList.add('lazyloaded'); n.classList.remove('lazyloading') };
                }

                var processNode = function (n) {
                    if (n.classList.contains('lazyload')) {
                        if (canGoNative(n)) {
                            goNative(n);
                        } else {
                            loadLazySizes();
                            if (!native) o.disconnect();
                        }
                    }
                    else if (n.tagName === 'IMG' && !n.classList.contains('normalloading')) {
                        n.classList.add('normalloading')
                        n.onload = function () { n.classList.add('normalloaded'); n.classList.remove('normalloading') };
                    }
                }

                var o = new MutationObserver(function (l) {
                    l.forEach(function (m) {
                        m.addedNodes.forEach(function (n) {
                            if (n.nodeType === 1) {
                                processNode(n);
                                n.querySelectorAll('.lazyload,img').forEach(function (e) { processNode(e) });
                            }
                        })
                    })
                });
                o.observe(d.documentElement, { subtree: true, childList: true });
            }(window,document)
        </script>

        {{!-- 
            CSS based LQIP support
            My modified responsive-img.html supports LQIP by using CSS background-image
            This CSS is needed to make the LQIP image match the positioning of the real image 
        --}}
        <style>          
            img.placeholder-lqip {
                background-repeat: no-repeat;
                background-size: contain;
                background-position: center;
            }
            img.placeholder-lqip.normalloaded, img.placeholder-lqip.lazyloaded {
                background-image: none !important;
            }
        </style>



        {{!--  the resourceHints are of no value --}}
        {{!--  {{{ resourceHints }}} --}}

        <link href="{{ head.favicon }}" rel="shortcut icon">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <script>
            {{!-- Change document class from no-js to js so we can detect this in css --}}
            document.documentElement.className = document.documentElement.className.replace('no-js', 'js');
        </script>

        {{> components/common/polyfill-script }}



        {{!-- 
            Main CSS - preload here so it starts quick, but only do the real tag at the end of the head so it does not block scripts in the head
    
            The recommended solution is to inline everything that does the main layout for a page and async load the rest.

            Categories pages are inlined at the moment. Work is needed to inline other page types.

            This is currently messing up the faceted navigation layout and the footer layout. So need a better solution!

            I used a tool (https://www.corewebvitals.io/tools/critical-css-generator) to work out essential CSS for the category page and inlined it. 

            The inlined css is added via pages/category.html using the head partial so that it is in the pages cache area.
            The main CSS for category pages is async loaded so it does not render block.
            When generating the inline code make sure to remove the fonts at the start as they are in the head section already.

            When the main CSS has loaded it removes the inline CSS via its id of inline-css. I found having both caused layout issues.

            I'm sure there is a better way to split the CSS into essential and non essential? 

            If we knew a user has probably a cache of the main CSS file we could skip including the inlined CSS and save a bit of data.
            
            main.js plays with a few things including the faceted navigation, and this causes a small layout shift.

        --}}
        <script>
            console.log('now css before: ' + performance.now());
        </script>
        {{#if page_type '===' 'category'}}
        {{{stylesheet '/assets/css/theme.css' rel="preload" as="style" fetchpriority="high" onload="this.onload=null;this.rel='stylesheet';var e=document.getElementById('inline-css');e.parentNode.removeChild(e);"}}}
        {{else}}
        {{!-- call it for real at the end of the head so it does not block scripts --}}
        {{{stylesheet '/assets/css/theme.css' rel="preload" as="style" fetchpriority="high"}}}
        {{/if}}
        <script>
            console.log('now css after: ' + performance.now());
        </script>

        {{!-- Different ways to load web fonts. do after js and css as they are smaller --}}
        {{!-- {{> components/common/fonts-webfontloader-inlined-css }} --}}
        {{> components/common/fonts-local-preload-inlined-css }}

        {{!-- 
            Header logo sizing. 
            Sizing the logo image reduces the chance of a layout shift and an issue being reported in Page Speed Insights/Lighthouse.
            I've added width and height to the logo if not set to use the original unknown size
            If your logo is not showing correctly then set its exact dimensions in Page Builder->Settings->Header & Footer
        --}}
        {{!-- Header logo preload --}}
        {{#if settings.store_logo.image}}
        {{#if theme_settings.logo_size '===' 'original'}}
        <link rel="preload" href="{{getImage settings.store_logo.image 'logo_size'}}" as="image" fetchpriority="high">
        {{else}}
        <link rel="preload" href="{{getImage settings.store_logo.image 'logo_size'}}" imagesrcset="{{getImageSrcset1x2x settings.store_logo.image theme_settings.logo_size}}" as="image" fetchpriority="high">
        {{/if}}
        {{/if}}
 
        {{!-- The sudden appearance of the scrollbar seemed to cause a layout shift, so I made it show from the start --}}
        <style>
            body {
                overflow: scroll; 
            }
        </style>



        {{!--        
            If you use Google Optimize a preload will help reduce flicker when it changes the page  
        --}}
        {{!--
        <link rel="preload" href="https://www.googleoptimize.com/optimize.js?id=OPT-XXXXXXX" crossorigin="anonymous" as="script" fetchpriority="high">
        --}}

        {{!-- 
            You can add other preloads for scripts that are important for display but are not initially requested. e.g. widgets

            Add crossorigin if it is used in the real script tag.
        --}}

        {{!-- Pre-connecting
            Place late in head script so are the last requests to be considered. 
            Only add what is used and is requested later on 
            These are browser hits. The browser will only apply them when it has time
            https://web.dev/preconnect-and-dns-prefetch/

            Tag Rocket preconnects to all the relevant domains
        --}}

        {{!-- 
            If we have certain BigCommerce widgets (Hero Banner, Carousel, Product, Product Set) they use external scripts. 
            Note that the code for these widgets runs really late as it is dynamically loading the scripts from within the body of the page.   
            Which means the content of the widgets takes some time to show.
            A preload on pages you know use one of these widgets would be better, but the URLs may unfortunately change on you!
            Having the widget some how add its own preload would work better.
        --}}
        {{!--
        <link rel="preconnect" href="https://microapps.bigcommerce.com">
        <link rel="dns-prefetch" href="https://microapps.bigcommerce.com">
        --}}

        {{!-- BigCommerce Recaptcha --}}
        {{!--       
        <link rel="preconnect" href="https://www.google.com">
        <link rel="dns-prefetch" href="https://www.google.com"> 

        <link rel="preconnect" href="https://www.gstatic.com">
        <link rel="dns-prefetch" href="https://www.gstatic.com">
        --}}

        {{!-- Shogun --}}
        {{!--            
        <link rel="preconnect" href="https://analytics.getshogun.com">
        <link rel="dns-prefetch" href="https://analytics.getshogun.com">
        --}}

        {{!-- Just Uno --}}
        {{!--        
        <link rel="preconnect" href="https://cdn.jst.ai">
        <link rel="dns-prefetch" href="https://cdn.jst.ai">
        
        <link rel="preconnect" href="https://my.jst.ai">
        <link rel="dns-prefetch" href="https://my.jst.ai">
        
        <link rel="preconnect" href="https://aly.jst.ai">
        <link rel="dns-prefetch" href="https://aly.jst.ai">
        --}}

        {{!-- 
            preload theme-bundle.main.js early as it is big and it is in the footer (required) and out of the cache 
            priority is low as it does not need to run quickly. Let the browser start loading it when it is good and ready 
            The footer waits until it creates the real script, so this is needed to make sure it gets going            
        --}}
        <link rel="preload" href="{{cdn 'assets/dist/theme-bundle.main.js'}}" crossorigin="anonymous" as="script" fetchpriority="low">

        {{!-- 
            Preload specific urls in the footer scripts.
            This is a hack. it would be better for the system to provide the preload stuff for us, and/or to implement fetchpriority 
        --}}
        {{#eachIndex (split footer.scripts '"')}}
        {{#startsWith "https://cdn11.bigcommerce.com/shared/js/csrf-protection-header-" item}}
        <link rel="preload" href="{{item}}" as="script" fetchpriority="low">
        {{/startsWith}}
        {{#startsWith "https://cdn11.bigcommerce.com/shared/js/datatags-" item}}
        <link rel="preload" href="{{item}}" as="script" fetchpriority="low">
        {{/startsWith}}
        {{/eachIndex}}

        {{!-- ****** Page Static Resources ****** --}}
        {{!-- Possible to cache at a page level. Rarely change but are page specific and could request resources --}}

        {{{ head.config }}}

        {{!-- This here assumes no users of this block add dynamic content --}}
        {{!-- checkout.html and order-confirmation.html do, in fact they also pulls in head.scripts --}}
        {{#block "head"}} {{/block}}

        {{!-- 
            This tells section.io where to cache up to.
            We want to make sure section.io do not cache on page types that don't have this line. Their standard blacklist is:
            checkout,cart.php,login.php,account.php,api,internalapi,remote,pageBuilder,login-as-customer,^/customer/,graphql,(\?|&).*
            What about:
            amp pages, product-options.html (amp iframe), 
            these use layout/empty instead of this: invoice.html, checkout.html, order-confirmation.html, maintenance.html
            If we could use </title> as the hole punch then all layouts would be fine.
        --}}

        {{!-- ****** Page Variable Resources ****** --}}
        {{!-- Frequently change so should not be cached. Or are tags that would not trigger any network requests. --}}
        {{!-- If you are using section.io set its hole punch to "<title" so caching stops here --}}

        <title>{{ head.title }}</title>
        {{{ head.meta_tags }}}

        <script>window.consentManagerTranslations = `{{{langJson 'consent_manager'}}}`;</script>

        <!-- head scripts start -->
        {{!-- This includes BCs GA and Facebook code, site verification code, a CSRF token (that can't be cached) and the head custom scripts --}}
        {{!-- BCs GA uses some CPU so may be better delayed a bit so it does not delay LCP --}}
        {{{head.scripts}}}
        <!-- head scripts end -->

        {{~inject 'zoomSize' theme_settings.zoom_size}}
        {{~inject 'productSize' theme_settings.product_size}}
        {{~inject 'genericError' (lang 'common.generic_error')}}
        {{~inject 'maintenanceModeSettings' settings.maintenance}}
        {{~inject 'adminBarLanguage' (langJson 'admin')}}
        {{~inject 'urls' urls}}
        {{~inject 'secureBaseUrl' settings.secure_base_url}}
        {{~inject 'cartId' cart_id}}
        {{~inject 'channelId' settings.channel_id}}
        {{~inject 'template' template}}
        {{~inject 'validationDictionaryJSON' (langJson 'validation_messages')}}
        {{~inject 'validationFallbackDictionaryJSON' (langJson 'validation_fallback_messages')}}
        {{~inject 'validationDefaultDictionaryJSON' (langJson 'validation_default_messages')}}
        {{~inject 'carouselArrowAndDotAriaLabel' (lang 'carousel.arrow_and_dot_aria_label')}}
        {{~inject 'carouselActiveDotAriaLabel' (lang 'carousel.active_dot_aria_label')}}
        {{~inject 'carouselContentAnnounceMessage' (lang 'carousel.content_announce_message')}}

        <script>
            console.log('now head end: ' + performance.now());
        </script>
        {{#if page_type '!==' 'category'}}
        {{!-- 
            real css call here. needs to be in the head but after scripts so it does not block them 
            it will block any scripts in the body
        --}}
        {{{stylesheet '/assets/css/theme.css' fetchpriority="high"}}}
        {{/if}}
        <script>  
            console.log('now head end css: ' + performance.now());
        </script>
    </head>
    <body>
        <svg data-src="{{cdn 'img/icon-sprite.svg'}}" class="icons-svg-sprite"></svg>

        {{> components/common/header }}
        {{> components/common/body }}
        {{> components/common/footer }}

        <script>window.__webpack_public_path__ = "{{cdn 'assets/dist/'}}";</script>

        {{!-- 
            Note that code after the head will not run until the css file has been loaded
            Not an issue here as we're not in a real rush to run this. 
            Stop theme-bundle.main.js from blocking
            Replace the theme-bundle.main.js script and stencilBootstrap script after it with this
            Needs to be after all uses of ~inject so jsContext is populated
            This supports async and still works on IE

            I tried a way to move it into the cached head, but unfortunately it depends on head being complete and probably body being mostly done.
            It would be nice to get some of it in the cached head so it can preload the chunks (that code also requires head).
        --}}
        <script>
            console.log('now end: ' + performance.now());

            !function(w,d){
                var done = false;
                
                var stencilBootstrapLoad = function () {
                    console.log('stencilBootstrapLoad');
                    {{!-- Exported in app.js --}}
                    // this has to be late so we have the jsContext filled in
                    w.stencilBootstrap("{{page_type}}", {{ jsContext }}).load();
                };
                
                var loadMainScript = function (onLoaded) {
                    console.log('loadMainScript');
                    var script = d.createElement('script');
                    script.src = "{{cdn 'assets/dist/theme-bundle.main.js'}}";
                    script.crossOrigin = "anonymous";
                    script.fetchpriority = "low";
                    script.async = true;
                    script.onload = script.onreadystatechange = function () {
                        if (!done) {
                            var readyState = script.readyState;
                            if (!readyState || readyState == 'loaded' || readyState == 'complete') {
                                done = true;
                                onLoaded();
                            }
                        }
                    }
                    d.head.appendChild(script);
                };
            
                 var lcpTracker = function(entryList) {
                    if (entryList) {
                         var entries = entryList.getEntries();
                         var lastEntry = entries[entries.length - 1];
                    
                         // Update `lcp` to the latest value, using `renderTime` if it's available,
                         // otherwise using `loadTime`. (Note: `renderTime` may not be available on
                         // image elements loaded cross-origin without the `Timing-Allow-Origin` header.)
                         lcp = lastEntry.renderTime || lastEntry.loadTime;
                         console.log('LCP '+lcp);
                     }
                 }

                var waitForLcp = function (onLcp, longestLcpWait = 2500) {
                    longestLcpWait = longestLcpWait || 2500; // LCP has failed anyhow, might as well run 

                    var onLcpCalled = !1;

                    var callOnLcp = function() {
                        if (!onLcpCalled) {
                            var args=[].slice.call(arguments);
                            args.unshift('On LCP Called:');
                            console.log.apply(console, args);

                            onLcpCalled = !0;
                            onLcp();

                        }
                    }

                    var lcpTimeLeft = longestLcpWait - performance.now();

                    console.log('lcpTimeLeft: '+longestLcpWait+' - ' + performance.now());

                    if (lcpTimeLeft <= 0) {
                        callOnLcp(longestLcpWait+' already reached');
                        return;
                    }
        
                    try {
  
                        if (!PerformanceObserver.supportedEntryTypes.includes('largest-contentful-paint')) {
                            // would DCL be close to this point anyhow. we are at the end of the html?
                            document.addEventListener('DOMContentLoaded', function() {
                                callOnLcp('LCP not supported, Waited on DCL');
                            });
                            return;
                        }

                        // the LCP bug can mean no LCP event until first interaction. timeout will help us there.
                        // also if something fails we always call the function
                        console.log('waitForLcp: waiting for '+lcpTimeLeft);
                        setTimeout(function() {
                            callOnLcp('timed out');
                        }, lcpTimeLeft);

                        // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/observe
                        const po = new PerformanceObserver(function() {
                            callOnLcp('LCP ' + performance.now());
                        });  
                        po.observe({type: 'largest-contentful-paint', buffered: true}); 
                    }
                    catch(e) {
                        // make sure we always call it
                        callOnLcp('exception', e);
                    }
                };

                // the carousel starts its time once main is loaded. If the first rotation is before LCP it affects it. Delaying main to after LCP solves it
                
                // load script after LCP. this stops any main.js activity until after LCP. It becomes late in the execution queue.
                waitForLcp(function() {loadMainScript(stencilBootstrapLoad)}, 10000);
                
                // load script then wait for LCP. main.js does a little code before LCP. Carousel code is after so does not delay things
                //loadMainScript(function() {waitForLcp(stencilBootstrapLoad)});
                
                // just load script. main.js gets gong before LCP plus the carousel animation may delay things even more.
                //loadMainScript(function() {stencilBootstrapLoad()});
                
                // track LCP
                //waitForLcp(lcpTracker);

            }(window,document)
        </script>

        {{{footer.scripts}}}


    </body>
</html>
